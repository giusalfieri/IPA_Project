<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Aircraft Detection: src/aircraft_detection_project/utils.cpp File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Aircraft Detection<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="../../dir_33b76457f0038000fc96ba03fce6c0bf.html">aircraft_detection_project</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">utils.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="../../d5/d60/utils_8h_source.html">utils.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a41bfe2f3b1a803c3a88c57d74b5c9451" id="r_a41bfe2f3b1a803c3a88c57d74b5c9451"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41bfe2f3b1a803c3a88c57d74b5c9451">degrees2rad</a> (double degrees)</td></tr>
<tr class="memdesc:a41bfe2f3b1a803c3a88c57d74b5c9451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts degrees to radians.  <br /></td></tr>
<tr class="separator:a41bfe2f3b1a803c3a88c57d74b5c9451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c651246901d33b6195bcd47584bea9a" id="r_a7c651246901d33b6195bcd47584bea9a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c651246901d33b6195bcd47584bea9a">rad2degrees</a> (double radians)</td></tr>
<tr class="memdesc:a7c651246901d33b6195bcd47584bea9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts radians to degrees.  <br /></td></tr>
<tr class="separator:a7c651246901d33b6195bcd47584bea9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4526ccf2b074f5834c36becab88ed8" id="r_a8b4526ccf2b074f5834c36becab88ed8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b4526ccf2b074f5834c36becab88ed8">sortByDescendingArea</a> (const <a class="el" href="../../d5/d60/utils_8h.html#af244936c81c51b8730818053c00284a1">object</a> &amp;first, const <a class="el" href="../../d5/d60/utils_8h.html#af244936c81c51b8730818053c00284a1">object</a> &amp;second)</td></tr>
<tr class="memdesc:a8b4526ccf2b074f5834c36becab88ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator function to sort contours by descending area.  <br /></td></tr>
<tr class="separator:a8b4526ccf2b074f5834c36becab88ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e270cb73cf33d731dc325c3a458b7f" id="r_a59e270cb73cf33d731dc325c3a458b7f"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59e270cb73cf33d731dc325c3a458b7f">rotate90</a> (cv::Mat img, int step)</td></tr>
<tr class="memdesc:a59e270cb73cf33d731dc325c3a458b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates an image by multiples of 90 degrees clockwise.  <br /></td></tr>
<tr class="separator:a59e270cb73cf33d731dc325c3a458b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312fe2e168c4ec3231ed4cfc75953780" id="r_a312fe2e168c4ec3231ed4cfc75953780"><td class="memItemLeft" align="right" valign="top">std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a312fe2e168c4ec3231ed4cfc75953780">createDirectory</a> (const std::filesystem::path &amp;folder_path, const std::string &amp;directory_name)</td></tr>
<tr class="memdesc:a312fe2e168c4ec3231ed4cfc75953780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new directory if it does not already exist.  <br /></td></tr>
<tr class="separator:a312fe2e168c4ec3231ed4cfc75953780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e99f2b0bbe078cc61fb6ccf31a8bf87" id="r_a8e99f2b0bbe078cc61fb6ccf31a8bf87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e99f2b0bbe078cc61fb6ccf31a8bf87">globFiles</a> (const std::string &amp;directory, const std::string &amp;pattern, std::vector&lt; std::string &gt; &amp;file_paths)</td></tr>
<tr class="memdesc:a8e99f2b0bbe078cc61fb6ccf31a8bf87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a list of file paths that match a specified pattern in a directory.  <br /></td></tr>
<tr class="separator:a8e99f2b0bbe078cc61fb6ccf31a8bf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cde9bd9232469a010a559dd554135cd" id="r_a5cde9bd9232469a010a559dd554135cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cde9bd9232469a010a559dd554135cd">readImages</a> (const std::vector&lt; std::string &gt; &amp;img_paths, std::vector&lt; cv::Mat &gt; &amp;images, int flags)</td></tr>
<tr class="memdesc:a5cde9bd9232469a010a559dd554135cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads images from a list of file paths and stores them in a vector.  <br /></td></tr>
<tr class="separator:a5cde9bd9232469a010a559dd554135cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65884b2e86600052b680f458db3ccead" id="r_a65884b2e86600052b680f458db3ccead"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65884b2e86600052b680f458db3ccead">processYoloLabels</a> (const std::string &amp;filePath, const cv::Mat &amp;img, std::vector&lt; cv::Rect &gt; &amp;yolo_boxes)</td></tr>
<tr class="memdesc:a65884b2e86600052b680f458db3ccead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes YOLO labels from a file and converts them to bounding boxes.  <br /></td></tr>
<tr class="separator:a65884b2e86600052b680f458db3ccead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2064814444dfb467df1832b5011f89c8" id="r_a2064814444dfb467df1832b5011f89c8"><td class="memItemLeft" align="right" valign="top">cv::Rect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2064814444dfb467df1832b5011f89c8">Yolo2BRect</a> (const cv::Mat &amp;img, double x_center, double y_center, double width, double height)</td></tr>
<tr class="memdesc:a2064814444dfb467df1832b5011f89c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts YOLO format bounding box coordinates to a <code>cv::Rect</code>.  <br /></td></tr>
<tr class="separator:a2064814444dfb467df1832b5011f89c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ddacb367ac7b452cadae7ecb60ac0d" id="r_a88ddacb367ac7b452cadae7ecb60ac0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88ddacb367ac7b452cadae7ecb60ac0d">isRoiInImage</a> (const cv::Rect &amp;roi, int width, int height)</td></tr>
<tr class="memdesc:a88ddacb367ac7b452cadae7ecb60ac0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a region of interest (ROI) is completely within the image boundaries.  <br /></td></tr>
<tr class="separator:a88ddacb367ac7b452cadae7ecb60ac0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98015f9c88eb4782fbbd8b27ec46ae18" id="r_a98015f9c88eb4782fbbd8b27ec46ae18"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cv::Rect &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98015f9c88eb4782fbbd8b27ec46ae18">readYoloBoxes</a> (const std::filesystem::path &amp;file_path, const cv::Mat &amp;img)</td></tr>
<tr class="memdesc:a98015f9c88eb4782fbbd8b27ec46ae18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads YOLO bounding boxes from a file and converts them to OpenCV <code>cv::Rect</code> format.  <br /></td></tr>
<tr class="separator:a98015f9c88eb4782fbbd8b27ec46ae18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972625046f7e8a754701d858e9c1deb7" id="r_a972625046f7e8a754701d858e9c1deb7"><td class="memItemLeft" align="right" valign="top">std::ofstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a972625046f7e8a754701d858e9c1deb7">openFile</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a972625046f7e8a754701d858e9c1deb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a file for writing and returns the output file stream.  <br /></td></tr>
<tr class="separator:a972625046f7e8a754701d858e9c1deb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5265ba1b4b265a288879155c326694b" id="r_aa5265ba1b4b265a288879155c326694b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cv::Rect &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5265ba1b4b265a288879155c326694b">generateRoisFromPoints</a> (const std::vector&lt; cv::Point &gt; &amp;points, const std::vector&lt; cv::Size &gt; &amp;roi_sizes)</td></tr>
<tr class="memdesc:aa5265ba1b4b265a288879155c326694b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates regions of interest (ROIs) from a set of points and ROI sizes.  <br /></td></tr>
<tr class="separator:aa5265ba1b4b265a288879155c326694b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ba8572ac6044a655f5195d61b8d613" id="r_a88ba8572ac6044a655f5195d61b8d613"><td class="memItemLeft" align="right" valign="top">cv::Size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88ba8572ac6044a655f5195d61b8d613">calculateAvgDims</a> (const std::filesystem::path &amp;directory_path)</td></tr>
<tr class="memdesc:a88ba8572ac6044a655f5195d61b8d613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the average dimensions of all images in a specified directory.  <br /></td></tr>
<tr class="separator:a88ba8572ac6044a655f5195d61b8d613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550dfa38799cb81e2a211529314d0fb7" id="r_a550dfa38799cb81e2a211529314d0fb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a550dfa38799cb81e2a211529314d0fb7">reshape2sameDim</a> (std::vector&lt; cv::Mat &gt; &amp;clustered_imgs_by_intensity, const cv::Size &amp;avg_dim)</td></tr>
<tr class="memdesc:a550dfa38799cb81e2a211529314d0fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes a vector of images to the same dimensions.  <br /></td></tr>
<tr class="separator:a550dfa38799cb81e2a211529314d0fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cb56a50f44fbcece605ed1d229a050" id="r_a43cb56a50f44fbcece605ed1d229a050"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43cb56a50f44fbcece605ed1d229a050">euclidean_distance</a> (const cv::Point &amp;a, const cv::Point &amp;b)</td></tr>
<tr class="memdesc:a43cb56a50f44fbcece605ed1d229a050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Euclidean distance between two points.  <br /></td></tr>
<tr class="separator:a43cb56a50f44fbcece605ed1d229a050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc38ef78ef855e943592f1d6329fd32" id="r_a5bc38ef78ef855e943592f1d6329fd32"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cv::Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bc38ef78ef855e943592f1d6329fd32">filterPointsByMinDistance</a> (std::vector&lt; cv::Point &gt; &amp;points, double min_distance)</td></tr>
<tr class="memdesc:a5bc38ef78ef855e943592f1d6329fd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a set of points by a minimum distance criterion.  <br /></td></tr>
<tr class="separator:a5bc38ef78ef855e943592f1d6329fd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112c779bcd4f5a8adcfb69fd653ca7fb" id="r_a112c779bcd4f5a8adcfb69fd653ca7fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a112c779bcd4f5a8adcfb69fd653ca7fb">listDirectories</a> (const std::filesystem::path &amp;directory_path, std::vector&lt; std::string &gt; &amp;final_paths)</td></tr>
<tr class="memdesc:a112c779bcd4f5a8adcfb69fd653ca7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively lists all leaf directories within a specified directory.  <br /></td></tr>
<tr class="separator:a112c779bcd4f5a8adcfb69fd653ca7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c5c4049dad43c7774dd142927e2a8e" id="r_a13c5c4049dad43c7774dd142927e2a8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13c5c4049dad43c7774dd142927e2a8e">imshow</a> (const std::string &amp;win_name, cv::InputArray arr, bool wait, float scale)</td></tr>
<tr class="separator:a13c5c4049dad43c7774dd142927e2a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210b4872a8521304552f931ea14cc6ae" id="r_a210b4872a8521304552f931ea14cc6ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a210b4872a8521304552f931ea14cc6ae">bitdepth</a> (int ocv_depth)</td></tr>
<tr class="separator:a210b4872a8521304552f931ea14cc6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a299aabc5fc8285cbf99025330a3d0d0d" id="r_a299aabc5fc8285cbf99025330a3d0d0d"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a299aabc5fc8285cbf99025330a3d0d0d">PI</a> = 3.14159265358979323846</td></tr>
<tr class="separator:a299aabc5fc8285cbf99025330a3d0d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a210b4872a8521304552f931ea14cc6ae" name="a210b4872a8521304552f931ea14cc6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210b4872a8521304552f931ea14cc6ae">&#9670;&#160;</a></span>bitdepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bitdepth </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ocv_depth</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88ba8572ac6044a655f5195d61b8d613" name="a88ba8572ac6044a655f5195d61b8d613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ba8572ac6044a655f5195d61b8d613">&#9670;&#160;</a></span>calculateAvgDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Size calculateAvgDims </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>directory_path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the average dimensions of all images in a specified directory. </p>
<p>This function reads all PNG images in the specified directory and calculates the average width and height of the images. It returns the average dimensions as a <code>cv::Size</code> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">directory_path</td><td>The path to the directory containing the images. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>cv::Size</code> object representing the average width and height of the images.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If no images are found in the directory or if any image fails to load.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the images are in PNG format.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>cv::glob </dd>
<dd>
cv::imread </dd>
<dd>
cv::Size </dd></dl>

</div>
</div>
<a id="a312fe2e168c4ec3231ed4cfc75953780" name="a312fe2e168c4ec3231ed4cfc75953780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312fe2e168c4ec3231ed4cfc75953780">&#9670;&#160;</a></span>createDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::filesystem::path createDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>folder_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>directory_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new directory if it does not already exist. </p>
<p>This function takes a base folder path and a directory name, creates the directory if it does not already exist, and returns the path to the created directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">folder_path</td><td>The base path where the new directory will be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">directory_name</td><td>The name of the directory to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::filesystem::path</code> object representing the path to the created directory.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the directory already exists, the function simply returns the path without creating a new directory.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::filesystem::exists </dd>
<dd>
std::filesystem::create_directory </dd></dl>

</div>
</div>
<a id="a41bfe2f3b1a803c3a88c57d74b5c9451" name="a41bfe2f3b1a803c3a88c57d74b5c9451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bfe2f3b1a803c3a88c57d74b5c9451">&#9670;&#160;</a></span>degrees2rad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double degrees2rad </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>degrees</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts degrees to radians. </p>
<p>This function converts an angle from degrees to radians.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">degrees</td><td>The angle in degrees. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The angle in radians. </dd></dl>

</div>
</div>
<a id="a43cb56a50f44fbcece605ed1d229a050" name="a43cb56a50f44fbcece605ed1d229a050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cb56a50f44fbcece605ed1d229a050">&#9670;&#160;</a></span>euclidean_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double euclidean_distance </td>
          <td>(</td>
          <td class="paramtype">const cv::Point &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Point &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the Euclidean distance between two points. </p>
<p>This function computes the Euclidean distance between two points <code>a</code> and <code>b</code> using the OpenCV <code>cv::norm</code> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Euclidean distance between the two points.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>cv::Point </dd>
<dd>
cv::norm </dd></dl>

</div>
</div>
<a id="a5bc38ef78ef855e943592f1d6329fd32" name="a5bc38ef78ef855e943592f1d6329fd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc38ef78ef855e943592f1d6329fd32">&#9670;&#160;</a></span>filterPointsByMinDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; cv::Point &gt; filterPointsByMinDistance </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Point &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>min_distance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters a set of points by a minimum distance criterion. </p>
<p>This function filters a vector of points, selecting only those points that are not closer than a specified minimum distance to any previously selected points. The points are first sorted by their coordinates to ensure consistent results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">points</td><td>A vector of <code>cv::Point</code> objects representing the points to be filtered. The vector is sorted by coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_distance</td><td>The minimum distance required between any two selected points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <code>cv::Point</code> objects representing the points that meet the minimum distance criterion.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a43cb56a50f44fbcece605ed1d229a050" title="Calculates the Euclidean distance between two points.">euclidean_distance</a> </dd>
<dd>
cv::Point </dd></dl>

</div>
</div>
<a id="aa5265ba1b4b265a288879155c326694b" name="aa5265ba1b4b265a288879155c326694b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5265ba1b4b265a288879155c326694b">&#9670;&#160;</a></span>generateRoisFromPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; cv::Rect &gt; generateRoisFromPoints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; cv::Point &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cv::Size &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>roi_sizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates regions of interest (ROIs) from a set of points and ROI sizes. </p>
<p>This function takes a vector of points and a vector of ROI sizes, and generates ROIs centered at each point with each of the given sizes. It ensures that the generated ROIs are within the image boundaries before adding them to the output vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>A vector of <code>cv::Point</code> objects representing the centers of the ROIs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roi_sizes</td><td>A vector of <code>cv::Size</code> objects representing the sizes of the ROIs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <code>cv::Rect</code> objects representing the valid ROIs.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function checks if each generated ROI is within the image boundaries before adding it to the output vector. </dd>
<dd>
The function assumes that the <code>isRoiInImage</code> function is defined and checks if an ROI is within the image boundaries.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a88ddacb367ac7b452cadae7ecb60ac0d" title="Checks if a region of interest (ROI) is completely within the image boundaries.">isRoiInImage</a> </dd></dl>

</div>
</div>
<a id="a8e99f2b0bbe078cc61fb6ccf31a8bf87" name="a8e99f2b0bbe078cc61fb6ccf31a8bf87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e99f2b0bbe078cc61fb6ccf31a8bf87">&#9670;&#160;</a></span>globFiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void globFiles </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>directory</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>file_paths</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a list of file paths that match a specified pattern in a directory. </p>
<p>This function uses the OpenCV <code>cv::glob</code> function to find all files in the specified directory that match the given pattern and stores the paths of these files in a vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">directory</td><td>The directory in which to search for files. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The pattern to match files against, such as "*.png". </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">file_paths</td><td>A vector of strings where the matching file paths will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::glob </dd></dl>

</div>
</div>
<a id="a13c5c4049dad43c7774dd142927e2a8e" name="a13c5c4049dad43c7774dd142927e2a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c5c4049dad43c7774dd142927e2a8e">&#9670;&#160;</a></span>imshow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imshow </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>win_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::InputArray</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>wait</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88ddacb367ac7b452cadae7ecb60ac0d" name="a88ddacb367ac7b452cadae7ecb60ac0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ddacb367ac7b452cadae7ecb60ac0d">&#9670;&#160;</a></span>isRoiInImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isRoiInImage </td>
          <td>(</td>
          <td class="paramtype">const cv::Rect &amp;</td>          <td class="paramname"><span class="paramname"><em>roi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a region of interest (ROI) is completely within the image boundaries. </p>
<p>This function checks whether a given ROI is entirely contained within the boundaries of an image with the specified width and height.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">roi</td><td>The region of interest represented as a <code>cv::Rect</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The width of the image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The height of the image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the ROI is completely within the image boundaries, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a112c779bcd4f5a8adcfb69fd653ca7fb" name="a112c779bcd4f5a8adcfb69fd653ca7fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112c779bcd4f5a8adcfb69fd653ca7fb">&#9670;&#160;</a></span>listDirectories()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void listDirectories </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>directory_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>final_paths</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively lists all leaf directories within a specified directory. </p>
<p>This function traverses the directory tree starting from the specified directory path and collects the paths of all leaf directories (directories that do not contain any subdirectories).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">directory_path</td><td>The path to the directory to start the traversal from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">final_paths</td><td>A vector of strings to store the paths of all leaf directories.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A leaf directory is defined as a directory that does not contain any subdirectories. </dd>
<dd>
The function uses recursion to traverse the directory tree.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::filesystem::directory_iterator </dd>
<dd>
std::filesystem::path </dd></dl>

</div>
</div>
<a id="a972625046f7e8a754701d858e9c1deb7" name="a972625046f7e8a754701d858e9c1deb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972625046f7e8a754701d858e9c1deb7">&#9670;&#160;</a></span>openFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ofstream openFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a file for writing and returns the output file stream. </p>
<p>This function opens a file with the specified filename for writing. If the file cannot be opened, it throws a <code>std::runtime_error</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The name of the file to be opened. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::ofstream</code> object representing the opened file stream.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the file cannot be opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65884b2e86600052b680f458db3ccead" name="a65884b2e86600052b680f458db3ccead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65884b2e86600052b680f458db3ccead">&#9670;&#160;</a></span>processYoloLabels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void processYoloLabels </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filePath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;</td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Rect &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>yolo_boxes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes YOLO labels from a file and converts them to bounding boxes. </p>
<p>This function reads a YOLO label file and converts the normalized bounding box coordinates to <code>cv::Rect</code> objects representing the bounding boxes in the image. The bounding boxes are then stored in a vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filePath</td><td>The path to the YOLO label file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The image in which the bounding boxes are defined. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">yolo_boxes</td><td>A vector of <code>cv::Rect</code> objects where the converted bounding boxes will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The YOLO label file should have the following format for each line: &lt;class_id&gt; &lt;center_x&gt; &lt;center_y&gt; &lt;width&gt; &lt;height&gt; where <code>center_x</code>, <code>center_y</code>, <code>width</code>, and <code>height</code> are normalized coordinates. </dd>
<dd>
The function skips lines that cannot be read or have bounding boxes that fall beyond the image boundaries.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2064814444dfb467df1832b5011f89c8" title="Converts YOLO format bounding box coordinates to a cv::Rect.">Yolo2BRect</a> </dd></dl>

</div>
</div>
<a id="a7c651246901d33b6195bcd47584bea9a" name="a7c651246901d33b6195bcd47584bea9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c651246901d33b6195bcd47584bea9a">&#9670;&#160;</a></span>rad2degrees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double rad2degrees </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>radians</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts radians to degrees. </p>
<p>This function converts an angle from radians to degrees.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radians</td><td>The angle in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The angle in degrees. </dd></dl>

</div>
</div>
<a id="a5cde9bd9232469a010a559dd554135cd" name="a5cde9bd9232469a010a559dd554135cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cde9bd9232469a010a559dd554135cd">&#9670;&#160;</a></span>readImages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void readImages </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>img_paths</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Mat &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>images</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads images from a list of file paths and stores them in a vector. </p>
<p>This function iterates through a list of image file paths, reads each image using OpenCV's <code>cv::imread</code> function with the specified flags, and stores the successfully read images in a vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img_paths</td><td>A vector of strings representing the paths to the image files to be read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">images</td><td>A vector of <code>cv::Mat</code> objects where the successfully read images will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>The flag that specifies the way the image should be read. This is passed to <code>cv::imread</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::imread </dd></dl>

</div>
</div>
<a id="a98015f9c88eb4782fbbd8b27ec46ae18" name="a98015f9c88eb4782fbbd8b27ec46ae18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98015f9c88eb4782fbbd8b27ec46ae18">&#9670;&#160;</a></span>readYoloBoxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; cv::Rect &gt; readYoloBoxes </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>file_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;</td>          <td class="paramname"><span class="paramname"><em>img</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads YOLO bounding boxes from a file and converts them to OpenCV <code>cv::Rect</code> format. </p>
<p>This function reads a file containing YOLO format bounding box coordinates and converts them to OpenCV <code>cv::Rect</code> objects, which are stored in a vector. The YOLO format assumes normalized coordinates in the range [0, 1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_path</td><td>The path to the file containing YOLO bounding box coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The image for which the bounding boxes are defined. Used to convert normalized coordinates to pixel values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <code>cv::Rect</code> objects representing the bounding boxes.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the file cannot be opened.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The expected format of each line in the file is: "class_id x_center y_center width height". </dd>
<dd>
If a line cannot be parsed, an error message is printed and the line is skipped. </dd></dl>

</div>
</div>
<a id="a550dfa38799cb81e2a211529314d0fb7" name="a550dfa38799cb81e2a211529314d0fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550dfa38799cb81e2a211529314d0fb7">&#9670;&#160;</a></span>reshape2sameDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reshape2sameDim </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Mat &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>clustered_imgs_by_intensity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Size &amp;</td>          <td class="paramname"><span class="paramname"><em>avg_dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes a vector of images to the same dimensions. </p>
<p>This function resizes each image in a vector of images to the specified average dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">clustered_imgs_by_intensity</td><td>A vector of <code>cv::Mat</code> objects representing the images to be resized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">avg_dim</td><td>The target dimensions to which all images will be resized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::resize </dd>
<dd>
cv::Mat </dd>
<dd>
cv::Size </dd></dl>

</div>
</div>
<a id="a59e270cb73cf33d731dc325c3a458b7f" name="a59e270cb73cf33d731dc325c3a458b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e270cb73cf33d731dc325c3a458b7f">&#9670;&#160;</a></span>rotate90()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat rotate90 </td>
          <td>(</td>
          <td class="paramtype">cv::Mat</td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>step</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates an image by multiples of 90 degrees clockwise. </p>
<p>This function rotates the input image by a specified number of 90-degree steps clockwise. The valid step values are 0 (no rotation), 1 (90 degrees), 2 (180 degrees), and 3 (270 degrees).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image to be rotated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>The number of 90-degree steps to rotate the image. A negative value is converted to its positive equivalent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>cv::Mat</code> object representing the rotated image.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function uses <code>cv::transpose</code> and <code>cv::flip</code> to perform the rotations. </dd>
<dd>
If <code>step</code> is greater than 3, it is reduced modulo 4 to ensure a valid number of steps.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>cv::transpose </dd>
<dd>
cv::flip </dd></dl>

</div>
</div>
<a id="a8b4526ccf2b074f5834c36becab88ed8" name="a8b4526ccf2b074f5834c36becab88ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4526ccf2b074f5834c36becab88ed8">&#9670;&#160;</a></span>sortByDescendingArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sortByDescendingArea </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d60/utils_8h.html#af244936c81c51b8730818053c00284a1">object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d60/utils_8h.html#af244936c81c51b8730818053c00284a1">object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparator function to sort contours by descending area. </p>
<p>This function compares the areas of two contours and returns <code>true</code> if the area of the first contour is greater than the area of the second contour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>The first contour. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>The second contour. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the area of the first contour is greater than the area of the second contour, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>cv::contourArea </dd></dl>

</div>
</div>
<a id="a2064814444dfb467df1832b5011f89c8" name="a2064814444dfb467df1832b5011f89c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2064814444dfb467df1832b5011f89c8">&#9670;&#160;</a></span>Yolo2BRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Rect Yolo2BRect </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;</td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x_center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y_center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>height</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts YOLO format bounding box coordinates to a <code>cv::Rect</code>. </p>
<p>This function converts normalized YOLO bounding box coordinates (center x, center y, width, height) to a <code>cv::Rect</code> with pixel coordinates, ensuring the bounding box is within the image boundaries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The image for which the bounding box is defined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x_center</td><td>The normalized x coordinate of the bounding box center. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_center</td><td>The normalized y coordinate of the bounding box center. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The normalized width of the bounding box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The normalized height of the bounding box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>cv::Rect</code> representing the bounding box in pixel coordinates. If the bounding box falls outside the image boundaries, an empty <code>cv::Rect</code> is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Normalized coordinates are in the range [0, 1]. The function converts these to pixel values. </dd>
<dd>
If the calculated bounding box exceeds the image boundaries, an empty <code>cv::Rect</code> is returned. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a299aabc5fc8285cbf99025330a3d0d0d" name="a299aabc5fc8285cbf99025330a3d0d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299aabc5fc8285cbf99025330a3d0d0d">&#9670;&#160;</a></span>PI</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double PI = 3.14159265358979323846</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
